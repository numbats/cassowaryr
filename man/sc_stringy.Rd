% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mst.R
\name{sc_stringy}
\alias{sc_stringy}
\alias{sc_stringy2}
\title{Compute stringy scagnostic measure using MST}
\usage{
sc_stringy(x, y, out.rm = TRUE, binner = "hex")

sc_stringy2(x, y, out.rm = TRUE, binner = "hex")
}
\arguments{
\item{x, y}{numeric vectors}

\item{out.rm}{logical; if TRUE, iteratively trim large MST edges, If FALSE
the scanostics will be computed on the entire data set with no outlier
removal.}

\item{binner}{an optional function that bins the x and y vectors prior
to triangulation
Can be:
\itemize{
\item \code{"hex"} (default): hexagonal binning following the procedure in the
graph-theoretic scagnostics paper (start 40x40, halve
until <= 250 nonempty cells)
\item \code{NULL}: no binning (use raw points)
\item a function: user-defined binner
}}
}
\value{
A numeric object that gives the plot's stringy score.
}
\description{
This measure identifies a “stringy” shape with no branches, such as a thin
line of data. The stringy function is defined in Scagnostics Distributions by
Wilkinson & Wills (2008). It is calculated by comparing the number of
vertices of degree two in the MST with the total number of vertices
in the MST, dropping those of degree one. The stringy2 function
is defined in Graph Theoretic Scagnostics, Wilkinson (2005). It is
the legnth of the longest shortest path through the MST divided by the
sum of all edge lengths in the MST.
}
\examples{
require(ggplot2)
require(dplyr)

# plot the features data
ggplot(features, aes(x=x, y=y)) +
  geom_point() +
  facet_wrap(~feature, ncol = 5, scales = "free")

# calculate using tidy code
features |>
 group_by(feature) |>
 summarise(stringy = sc_stringy(x,y))

# using just vectors of points
x <- datasaurus_dozen_wide$star_x
y <- datasaurus_dozen_wide$star_y

# plot it
ggplot() +
  geom_point(aes(x = x, y = y))

# calculate using vectors
sc_stringy(x, y)

}
