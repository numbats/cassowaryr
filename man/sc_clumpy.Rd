% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mst.R
\name{sc_clumpy}
\alias{sc_clumpy}
\title{Compute clumpy scagnostic measure using MST}
\usage{
sc_clumpy(x, y, out.rm = TRUE, binner = "hex")
}
\arguments{
\item{x, y}{numeric vectors}

\item{out.rm}{logical; if TRUE, iteratively trim large MST edges, If FALSE
the scanostics will be computed on the entire data set with no outlier
removal.}

\item{binner}{an optional function that bins the x and y vectors prior
to triangulation
Can be:
\itemize{
\item \code{"hex"} (default): hexagonal binning following the procedure in the
graph-theoretic scagnostics paper (start 40x40, halve
until <= 250 nonempty cells)
\item \code{NULL}: no binning (use raw points)
\item a function: user-defined binner
}}
}
\value{
A numeric object that gives the plot's clumpy score.
}
\description{
This measure is used to detect clustering and is calculated through an
iterative process. It was first defined in Graph Theoretic Scagnostics,
Wilkinson, et al. (2005). First an edge J is selected and removed from the
MST. From the two spanning trees that are created by this break, we select
the largest edge from the smaller tree (K). The length of this edge (K) is
compared to the removed edge (J) giving a clumpy measure for this edge.
This process is repeated for every edge in the MST and the final clumpy
measure is the maximum of this value over all edges.
}
\examples{
require(ggplot2)
require(dplyr)

# plot the feature
ggplot(features, aes(x=x, y=y)) +
   geom_point() +
   facet_wrap(~feature, ncol = 5, scales = "free")

# calculate using tidy code
features |>
  group_by(feature) |>
  summarise(clumpy = sc_clumpy(x,y))

# using two vectors
x <- datasaurus_dozen_wide$slant_up_x
y <- datasaurus_dozen_wide$slant_up_y

# plot it
ggplot() +
  geom_point(aes(x = x, y = y))

# calculate using vectors
sc_clumpy(x, y)

}
